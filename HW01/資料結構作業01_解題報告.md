# 資料結構作業01_解題報告

[![hackmd-github-sync-badge](https://hackmd.io/hpMuvq2hTBym8SnTPXPa0A/badge)](https://hackmd.io/hpMuvq2hTBym8SnTPXPa0A)


###### tags: `資料結構` `C`

<style>
h2::first-letter
{
    color:#ff6600;
    font-size:1.2em;
}
h3::first-letter
{
    color:#ff9933;
    font-size:1.2em;
}
</style>

## 比較深度和廣度的差異
### 深度優先搜尋(DFS)
![](https://i.imgur.com/Q48QtjM.gif)
由起點開始探尋，先探尋邊上未搜尋的一節點，並儘可能深的搜索，直到該節點的所有邊上節點都已探尋；就回溯到前一個節點，重覆探尋未搜尋的節點，直到找到終點或遍尋全部節點。

- 實作方式: 遞迴、Stack
- 優點: 可窮舉
- 缺點: 速度慢、優化有限、難理解

### 廣度優先搜尋(BFS)
![](https://i.imgur.com/vmZpEEo.gif)

從起點開始走訪，接著走訪此一節點所有相鄰且未拜訪過的節點，由走訪過的節點繼續進行先廣後深的搜尋。以樹來說即把同一深度的節點走訪完，再繼續向下一個深度搜尋，直到找到終點或遍尋全部節點。

- 實作方式: 迴圈、Queue
- 優點: 速度快、易理解
- 缺點: 難窮舉、只記錄最短路徑、優化效益不大

---

## 1-1 2D_maze

==使用演算法: 廣度==
1-1是2D的迷宮，題目只要求找出最短路徑，因此廣度即夠用了。

### 演算法
廣度搜尋的實作方法為建立一個紀錄路徑距離的二維陣列(bmark)，初始化的值給很大(如:99)，變數level一開始設為0，接者將起點設為0，找尋這一點上下左右的格子是不是可以走的，並且**新的值是否小於原先存放的值**(這就是為什麼初始化才要存99)，如果符合以上兩種條件，那就將它設為**level+1**，並將它的座標**加入Queue中**，以便下次搜尋時尋找位置(另外比較暴力的作法是每做一次就掃瞄一整張地圖，但測資太大就會很沒效率)。如此反覆，每次**level++**，直到抵達終點或全部點都走過。

> **Q:** 怎麼判斷全部點都走過?
> **A:** 只要level掃過，發現已經沒有新的點再增加了，也就是rear沒有前進，代表全部點都已經走過了。

如果有抵達終點，那終點位置所存的值就是最點路徑囉~

關於畫出路徑的部分，Queue往回推就有了，不是用Queue的人也可以從終點相鄰的點找一個比自己小1的數字，慢慢回推到起點。

:::spoiler 範例
```
S O O
X O O
F O O

bmark:
//初始
 0 99 99
99 99 99
99 99 99

//執行第一次
 0  1 99
99 99 99
99 99 99

//執行第二次
 0  1  2
99  2 99
99 99 99

//執行第三次
 0  1  2
99  2  3
 4  3  4

最點路徑=4
```
:::


---

## 2-1 3D_maze

==使用演算法: 廣度==
2-1變成3D的迷宮，但題目也只要求找出最短路徑，因此廣度就OK了。

### 演算法
2-1概念上和1-1一樣，只不過要多考慮到U(上樓)、D(下樓)、T(陷阱)這三種情況而已。
這題的陣列全部改成三維陣列，讀檔部分要下點功夫，這邊就不多說了。
一樣是把起點設為0，只是變成六個方向，並且在U和D時多判斷樓上或樓下是否可以走(⚠ 在底層時不能往下，在頂層時也不能往上)，當踩到T時，就將自己相鄰格子的值設為**level+3**，其他照著1-1的做就好。

:::spoiler 範例
```
X X X X X 
O U O X X 
X O X U X 
O O D X X 
S O O X X 

T O X 
X U O 
O X O 

F 

bmark:
99 99 99 99 99
 5  4  5 99 99
99  3 99 99 99
 1  2  3 99 99
 0  1  2 99 99

 5  8 99
99  9 10
99 99 11

10

最短路徑=10
```
:::


---

## 2-2 5步內的可能性
==使用演算法: 廣度 + 深度==
聽到可能性，自然就聯想到窮舉法，沒錯，這題要用到深度了!

### 演算法
==先廣度，再用廣度的結果做深度的優化==

第一次先跑一遍廣度，如同2-1，會得到**min(最短路徑)**，這個值存著等等會用到。

接著是麻煩的深度搜尋來了，它的原理大概是長這樣:
宣告一種struct叫element，如下:
```
typedef struct		//結構: stack 走經的路徑 
{
	char alp;	//字母: T和P時會用到 
	short int flo;	//樓層 
	short int row;	//橫列 
	short int col;	//直行 
	short int dir;	//方向 
}element;
```

並利用element建立好一個stack和紀錄堆疊頂端的top。
然後將起點存為stack的第一個點，接著就重複進行**前進**和**後退**這兩種動作:
- **前進**
    先檢查該點的上下左右(U和D要特別判斷上樓下樓)可不可走，用dir:0~5代表六種方向，檢查只會跑一遍而且是不可逆的，所以如果執行到dir=2就有路了，就不會再繼續檢查到3，那如果所有方向都沒有路可以走，那就會執行**後退**。

    可走的那個點如果是F，那就找到終點了嘛，這個時候的cost(路徑長)如果有在min+5內的話，則posi(紀錄可能性的變數)++，但不要急著結束迴圈，而是執行**後退**，

    可走的那個點如果是如果是其他字母(O、T、U、D)，那就移動位置，先將下一點mark為1，然後將該點本身的flo、row、col、alp、dir通通存在stack頂端，最後移動到下一點的位置，同時dir歸零。

    另外為了處理陷阱問題，**移動時如果該點本身就是T，則cost+=3**，如果不是就cost++。
    
- **後退**
    取出stack頂端的值，**如果取出的alp是T，則cost要減3回去**，如果不是就cost-\-。

    想想看，我們當初stack的element中就已經存放dir，所以當我們取出element，它便會從當前的dir繼續++，因此不可能經過相同的路徑到達終點，這就是我說的"檢查只會跑一遍而且是不可逆的"。

    ⚠ **路徑退回上一個點時，記得要將mark恢復為0**，如此一來下一次的可能性才可以通過。
    
**終止條件**
當top==-1的時候，代表所有可能的路徑都已經走過了。
    
**優化**
也許你已經發現了，這樣子全部可能性跑一遍需要花費非常大量的時間，早就超過規定的8秒了，因此優化非常重要。

⚠ 正因為題目只要求我們計算最短路徑5步內的可能數，所以每次移動時，只要**cost超過min+5**就不需要再計算這條路了，直接break出去。
    
最後，印出min(最短路徑)和posi(五步內的可能數)，就大功告成啦~

---

## 2-3 必經P之路徑
==使用演算法: 深度==
2-3再不確定經過P是不是最短路徑的情況下，廣度就無用武之地了

### 演算法
我2-3的演算法比較奇耙，所運用的技巧類似2-1的T，但是幾乎可以解決所有情況。

首先讀檔時順便數一下pNum(P的總數量)
然後刪掉2-2的廣度，其餘跟上一題一模一樣，只需要在**前進**和**後退**多考慮兩種情況就好。

- **前進**
如果自已踩的這點，和要移動過去的下一點都是P的話，代表兩個P相連，pCtn(P的連續數)加1。
- **後退**
如果如果自已踩的這點，和它的上一點都是P的話，代表兩個P相連，pCtn減1。
- **到達終點時...**
如果pCtn不等於pNum-1，代表P不是一口氣走完的，否則就計入可能性中。

這種演算法大方向是這樣: **全部可能性跑一遍，在挑選出符合通過P路徑的次數**
而符合通過P路徑的情況就是: **一口氣連續走完P，中途沒有任何中斷**

**圖示**
![](https://i.imgur.com/iPcGW2X.png)

---

## 小結
總之，這次作業很難單純只使用一種搜尋法來完成所有題目，甚至有需要深度廣度並用的題目，技巧性滿高的，還有其他廣度的優化(ex.Astar)我沒去做，就讓其他人來補充吧
`ヾ(*´∀｀*)ﾉ` 

感覺比起資料結構，比較多是在想演算法的問題呀(?)

反正DFS和BFS學演算法也會用到，先學起來也不虧😗

by @AndyChiang 

> [time=Tue, Oct 27, 2020 12:53 AM]

haha