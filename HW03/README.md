# 資料結構作業03_解題報告

###### tags: `資料結構` `C`

> 因為事隔半年後才來補這個坑，所以這篇文我不會寫的很詳細，大概提一下我的解法而已，幸好我的扣都有寫註解，如果不懂可以看我的扣。

## 1. A Sad Teaching Assistant

### 1-1

給你一串整數陣列，會有兩種指令(P, x, y)和(M, x, y)，(P, x, y)是印出`[i, j]`區段的最大值，𝑥 ≤ 𝑖 ≤ 𝑗 ≤ 𝑦。(M, x, y)則是將index=x的值改成y。

**重點!所有指令操作都必須在O(logN)內完成!**

看到logN就跟樹脫離不了關係了，這題要用到**二元區段樹**，是二元搜尋樹的變形，

**二元區段樹每個結點代表一個區段，他的子結點則代表從中間分開的左區段跟右區段。**

![](https://i.imgur.com/zQbOH7f.jpg)

一個結點有四個最大值，分別是**整段的、從左邊數來的、從右邊數來的、包含在中間的**。

當兩個區段接合時，也會產生四個新的最大值。

#### 整段的：左邊整段+右邊整段

![](https://i.imgur.com/uIzM8Pj.jpg)

#### 從左邊數來的：max(左邊從左邊數來, 左邊整段+右邊從左邊數來)

![](https://i.imgur.com/rU87nwN.jpg)

#### 從右邊數來的：max(右邊從右邊數來, 右邊整段+左邊從右邊數來)

![](https://i.imgur.com/guMyZqp.jpg)

#### 包含在中間的：max(左邊包含在中間, 右邊包含在中間, 右邊從左邊數來+左邊從右邊數來)

![](https://i.imgur.com/y3PAhB3.jpg)

在建立樹的時，就已經將每個區段的四個最大值算好了，執行P指令時只是將`[x, y]`區段中所有的小區段結合起來得到`[x, y]`區段，其中四個最大值中最大的就是答案。

搜尋的方式是用二元搜尋樹，如果最小值比區分值小，則向左找，如果最大值比區分值大，則向右找。複雜度是**O(2logN)**。

以上P指令的部分，至於M指令也是用二元搜尋法，找到對應的index，找到後記得要順著原路徑更新四個最大值，複雜度是**O(logN)**。

### 1-2

P指令變成(P, x1, y1, x2, y2)，請求`[i, j]`區段的最大值，𝑥1 ≤ 𝑖 ≤ 𝑦1, 𝑥2 ≤ 𝑗 ≤ 𝑦2, 𝑤ℎ𝑖𝑙𝑒 𝑥1 ≤ 𝑥2, 𝑦1 ≤ 𝑦_2。

其實概念上類似的，我們將兩個區段分成有重疊跟沒重疊，並分成ABC三塊。

#### 有重疊的

* A的右邊+B的全部+C的左邊
* A的右邊+B的左邊
* B的右邊+C的左邊
* B的中間

![](https://i.imgur.com/73Sbpzm.jpg)

#### 沒重疊的

* A的右邊+B的全部+C的左邊

![](https://i.imgur.com/BWRunmI.jpg)

針對A、B、C這三塊做剛才第一題的P指令，最後再從這幾種組合中找出做最大的就是答案。

## 2. Morse Code

### 2-1 English dictionary to Morse code

給你一堆單字，然後再給你一端堆摩斯密碼，請你求出這些摩斯密碼有沒有出現在單字中。

最直接暴力的解法，將所有的單字都轉成摩斯密碼，建立一個摩斯密碼的字典，然後把每個摩斯密碼一個個比對有沒有相同的，複雜度是**O(M\*N\*L)**。

比較好的解法是將摩斯密碼轉為**二元搜尋樹**， `.` 就往左， `-` 就往右，樹中的葉節點就是存在的單字，這樣的複雜度是**O(M\*L)**，L是摩斯密碼的長度。

### 2-2 Determine if two words have the same prefix

給你一個單字keyword，以及其他N個單字words，請你將這些單字都轉成摩斯密碼後，比較words跟keyword是屬於**完全相同、前綴相同還是不相同**。

跟2-1一樣，簡單暴力法就是每個摩斯去驗證，複雜度是**O(N\*min(Length(keyword), Length(words)))**。

用二元搜尋樹也行，但好像沒有比較快(?)。

### 2-3 With the dictionary and the program, you only need to check the part of the interpretations

給你一串摩斯密碼code和一堆單字，請求出所有組合這些單字的摩斯密碼符合code的可能性。

這題就一定要用二元搜尋樹了，因為會有太多種的可能性了。

於是我建了一個字典樹，每個單字的摩斯密碼都從root開始，`.` 就往左， `-` 就往右，最後停留的節點就將數字num+1，num表示該點有幾個有效的單字。

接著將code從頭開始一個個讀取，讀到 `.` 就往左，讀到 `-` 就往右，在字典樹中移動的點我稱作動點(move point)。

動點我使用Queue來追蹤，**每次從Queue取出這一輪的動點，移動過後新的動點又再加入Queue中**，如果動點跑到null去的話，就是不可能的組合，直接捨棄沒有關係。

動點裡面存放一個值sum，表示該動點累積的可能性，如果遇到num > 0的節點，表示出現num個可能的組合，因此這時會分裂兩個點，一個點繼續向下搜尋，另一個點回到root，回到root的這個點的sum值，會變成 **sum(累積數)\*nums(可能性)**，因為有可能同時兩個動點回到root，也要考慮合併的情況，**最後Queue中的動點總和就是答案**。

## 小結

第一和第二題都使用到了二元搜尋樹的概念，如果你連一個二元搜尋樹都建立不出來的話，那基本上可以說別想解這幾題了，如此一來就知道這有多重要。

這兩題對二元搜尋樹的想法都有點抽象，我也很難用畫圖來表示，我已經盡力去說明了，希望大家可以看得懂。

> 看完覺得有幫助的話，就幫我點個右上角的star吧! 你的鼓勵是我繼續創作的原動力~

by @AndyChiang  

> [time=Wed, Jul 14, 2021 7:31 PM]

