第一大題：
樹可以記錄的不只是一個int而已。
這題要做到的事情不只是「存東西」，而是讓你在更新節點的時候一面把子問題給解決。
 
也就是說，你樹的節點上會記錄某種資訊，當你在碰到M指令的時候，你更新節點上的那些解題必要的資訊，碰到P指令的時候，把那些資訊彙整起來變成答案。
 
先想像一下這件事，然後接著再思考這題的子問題應該設計成什麼樣子？
既然已知用樹來做，那就想像一下，葉子應該是切得最小的子問題。那對於這題，最小的子問題自然就是當數列只有一個數的時候。
也就是說，你的葉節點會存放所有值，即index[1..N]（如果我沒記錯的話）。parent自然存放這兩個子問題merge起來的結果。
 
要注意，即使你葉節點只有一個數，考慮到你父母節點要解的問題，你每個節點要存放不只一個值來給他們足夠的資訊。
 
2020/11/21
第一大題：
你會需要建立一棵為了「維護這題的答案」而存在的樹。
當你看到「修改」的操作在log n的時候，你應該要很直覺的想到是樹。
 
先想像一下，假如有一個樹，他的中位數在root，且對於所有node，比他小的在左節點、比他大的在右節點。
也就是說，這是一棵平衡的binary search tree。你要對任何節點做搜尋，你都是從root->child->child->...就能找到他，樹高最高就是log n，即：
3筆資料，最深只要找到兩層
7筆資料，最深只要找到三層
15筆資料，最深只要找到四層
……
 
這是之所以樹能把很多n的問題變成log n的原因，假如你以後到演算法上到binary search、或是你去看一下後面章節的Quick sort應該就會更明白這點。
 
 
第二大題：
2-1、2-2，input size我沒有什麼規定，基本上只要你公開測資跑得出來就行，我只會用幾筆簡單的隱藏測資來測。
2-3部分，以下是我給寄信來請教的同學的提示，因為公平性就公開給大家：
假如你想要通過複雜的測資（公開測資4），你需要往這個方向去想：
我們要求的摩斯序列是：-.---...---
甲、乙兩個組合的摩斯序列都是-.---...，那麼可能的組合就是
甲--- 和乙---，也就是說---的部分是被重複計算的。
 
意即：當你做完甲---的所有可能性時候，你就已經知道---的所有可能性了，那麼你在做乙---的時候就不該去重複計算---的可能性，而是直接把乙---的可能數量設成甲---的可能數量
 
你當然不用針對-.---...來做一個像是c++ map或是python dictionary的比對，你只需要把他們當成前綴來做就好了，所以你只要記錄當你抵達index7的時候，我剩下的摩斯序列就是---
 
 
最後廢話一下：
樹真的是一個很重要很重要的結構，我以前大學解題也覺得linked list、tree根本沒人要用，不知道在幹嘛。就建一個global array，size給他999999，直接搞定。別人用樹logN，我隨機存取O(1)還比你快。
但是資工系出來和速成班出來的人差別之一其實就是你能夠瞭解這些東西，實際碰到問題的時候知道要用什麼來做是最好的，那些都是你在學期間累積出來的成果，是他們速成班include/import模組沒有辦法複製的。
喔還有，樹有很多沒辦法模組化的種類，會需要你手刻，越硬體的部分越是。只是那大部分都是高等樹，需要rotaion之類的。它們能把非常多問題降到nlogn或是logn能解的，大部分都是與在線操作（維護某種狀態）相關。
 
最後，第一大題我腦內模擬應該可以用離線的方法，用一個二維的array+時間戳記應該能解，但是那個我想像中覺得滿難的，想跟我說我就是要用array、array就是強的人可以試試看。
離線方法就是把那些M、P也當成input丟進你的演算法裡面。在線方法就是碰到一個M做一個操作、碰到一個P做一個操作。
 
希望大家可以好好想想這次的題目，不要碰到樹就好像看到鬼一樣，謝謝大家。